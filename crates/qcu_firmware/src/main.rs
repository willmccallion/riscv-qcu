//! Firmware main entry point and multi-core decoding scheduler.
//!
//! Implements the primary firmware logic for a multi-core quantum error
//! correction system. The firmware runs on multiple RISC-V hardware threads
//! (harts), with hart 0 acting as the primary core that loads the decoding
//! graph and generates syndrome packets, while other harts act as worker
//! cores that process decoding jobs from a shared queue.

#![no_std]
#![no_main]
#![feature(allocator_api)]
#![feature(generic_const_exprs)]
#![allow(incomplete_features)]

extern crate alloc;

use core::cell::UnsafeCell;
use core::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};
use qcu_core::allocator::BumpAllocator;
use qcu_core::decoder::UnionFindDecoder;
use qcu_core::graph::DecodingGraph;
use qcu_core::spmc::StaticQueue;
use qcu_core::static_vec::StaticVec;

#[cfg(feature = "use_fpga_mmio")]
use crate::drivers::accelerator::DecoderAccelerator;

/// UART console interface for firmware debugging output.
///
/// Provides formatted printing to the QEMU UART device with thread-safe
/// synchronization for multi-core environments. Used for boot messages,
/// statistics reporting, and error diagnostics.
mod console;

/// Hardware driver modules for accelerator and physics simulation.
///
/// Contains drivers for FPGA-accelerated decoding operations and quantum
/// physics simulation. The accelerator driver provides MMIO access to
/// hardware-accelerated union-find operations when the `use_fpga_mmio`
/// feature is enabled.
mod drivers;

/// RISC-V trap and interrupt handler implementation.
///
/// Handles machine-mode traps and timer interrupts from the CLINT (Core
/// Local Interruptor). Timer interrupts are disabled by scheduling them
/// far in the future, allowing the firmware to run without periodic
/// interrupt overhead.
mod trap;

/// Build-time generated benchmark data module.
///
/// Contains pre-compiled syndrome data embedded in the firmware binary
/// for testing and benchmarking purposes.
mod bench_data {
    include!(concat!(env!("OUT_DIR"), "/bench_data.rs"));
}

/// Embedded decoding graph description in DEM format.
///
/// Loaded at compile time from the output directory. Used to initialize
/// the decoding graph structure during firmware boot.
static DEM_DATA: &str = include_str!("../../../output/bench.dem");

use core::alloc::{GlobalAlloc, Layout};

/// Dummy global allocator that rejects all allocation requests.
///
/// The firmware uses custom bump allocators for specific memory regions
/// rather than a global heap. This allocator ensures that any accidental
/// use of the global allocator API will fail immediately, preventing
/// silent memory corruption.
struct DummyAlloc;

unsafe impl GlobalAlloc for DummyAlloc {
    /// Always returns null, rejecting all allocation requests.
    ///
    /// This ensures that code attempting to use the global allocator will
    /// fail immediately rather than causing undefined behavior.
    unsafe fn alloc(&self, _layout: Layout) -> *mut u8 {
        core::ptr::null_mut()
    }

    /// No-op deallocation function.
    ///
    /// Since allocations always fail, deallocation is never needed.
    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}
}

/// Global allocator instance that rejects all allocation requests.
///
/// The firmware uses custom bump allocators for specific memory regions
/// rather than a global heap. This allocator ensures that any accidental
/// use of the global allocator API will fail immediately, preventing
/// silent memory corruption from unexpected heap allocations.
#[global_allocator]
static GLOBAL: DummyAlloc = DummyAlloc;

/// Number of 64-bit words required to store syndrome data for one shot.
///
/// Each word can represent 64 detector bits, so this constant determines
/// the maximum number of detectors supported per quantum measurement shot.
const WORDS_PER_SHOT: usize = 160;

/// Maximum number of nodes the decoder can handle.
///
/// This limit is enforced at compile time via the decoder's const generic
/// parameter. Must be large enough to accommodate the largest decoding
/// graph that will be processed.
const MAX_NODES: usize = 10240;

/// Packet containing syndrome data for a single quantum measurement shot.
///
/// Encapsulates all syndrome bits from one measurement cycle, along with
/// metadata for tracking and latency measurement. The syndrome data is
/// packed as u64 words for efficient processing and transmission between
/// cores via the job queue.
#[derive(Clone, Copy)]
pub struct SyndromePacket {
    /// Unique identifier for this measurement shot.
    ///
    /// Used for tracking and correlation with input data. Increments
    /// sequentially as shots are generated by the primary core.
    pub shot_id: u64,

    /// Timestamp when this packet was created (machine timer ticks).
    ///
    /// Used to measure decoding latency by comparing against the timestamp
    /// when decoding completes. Enables real-time performance monitoring
    /// and throughput calculation.
    pub timestamp: u64,

    /// Packed syndrome bits as an array of u64 words.
    ///
    /// Each bit represents one detector, with bit 0 of the first word
    /// corresponding to detector 0, bit 1 to detector 1, etc. The array
    /// size is WORDS_PER_SHOT, supporting up to WORDS_PER_SHOT * 64 detectors.
    pub syndromes: [u64; WORDS_PER_SHOT],
}

/// Global job queue for distributing decoding work to worker cores.
///
/// The primary core (hart 0) pushes syndrome packets into this queue,
/// and worker cores (hart 1+) pop packets and process them. The queue
/// uses a single-producer multi-consumer design to handle concurrent
/// access from multiple worker threads safely.
pub static JOB_QUEUE: StaticQueue<SyndromePacket, 512> = StaticQueue::new();

/// Atomic counter tracking the current depth of the job queue.
///
/// Maintained by incrementing on push and decrementing on pop. Used for
/// monitoring queue utilization and detecting backpressure when the queue
/// approaches capacity. Can go negative temporarily due to race conditions,
/// but stabilizes over time.
pub static QUEUE_DEPTH: AtomicI64 = AtomicI64::new(0);

/// Flag indicating that system initialization is complete.
///
/// Set to true by the primary core after the decoding graph is loaded and
/// ready for use. Worker cores spin-wait on this flag before starting to
/// process jobs, ensuring they don't access uninitialized graph data.
static SYSTEM_READY: AtomicBool = AtomicBool::new(false);

/// Total number of syndrome packets successfully decoded.
///
/// Incremented by worker cores after completing each decoding operation.
/// Used for throughput calculation and performance reporting by the
/// primary core's statistics loop.
static TOTAL_PROCESSED: AtomicU64 = AtomicU64::new(0);

/// Sum of all decoding latencies (for average calculation).
///
/// Accumulates the latency (in machine timer ticks) for each decoded packet.
/// Reset periodically by the primary core when computing statistics, then
/// divided by the number of processed packets to compute average latency.
static LATENCY_SUM: AtomicU64 = AtomicU64::new(0);

/// Maximum decoding latency observed.
///
/// Tracks the worst-case latency across all decoded packets. Reset periodically
/// by the primary core when computing statistics. Used to identify performance
/// outliers and worst-case timing behavior.
static LATENCY_MAX: AtomicU64 = AtomicU64::new(0);

/// Minimum decoding latency observed.
///
/// Tracks the best-case latency across all decoded packets. Reset periodically
/// by the primary core when computing statistics. Initialized to u64::MAX
/// so the first measurement becomes the minimum.
static LATENCY_MIN: AtomicU64 = AtomicU64::new(u64::MAX);

/// Thread-safe wrapper for global mutable state.
///
/// Provides interior mutability for global variables that need to be modified
/// from multiple contexts (different harts or interrupt handlers). Uses
/// UnsafeCell to allow mutable access through immutable references, with
/// Sync implementation relying on external synchronization guarantees.
struct GlobalCell<T>(UnsafeCell<T>);

/// GlobalCell is safe to share between threads when T is Send.
///
/// The UnsafeCell allows mutable access, but the caller must ensure proper
/// synchronization (e.g., only one hart modifies the value, or external
/// locks are used).
unsafe impl<T> Sync for GlobalCell<T> {}

impl<T> GlobalCell<T> {
    /// Creates a new GlobalCell with the specified initial value.
    ///
    /// Wraps the value in an UnsafeCell to enable interior mutability.
    /// The value can be accessed mutably via get_mut() even through an
    /// immutable reference to the GlobalCell.
    ///
    /// # Arguments
    ///
    /// * `val` - Initial value to store
    const fn new(val: T) -> Self {
        Self(UnsafeCell::new(val))
    }

    /// Returns a mutable reference to the stored value.
    ///
    /// # Safety
    ///
    /// The caller must ensure that no other code is concurrently accessing
    /// the value, or that proper synchronization is in place. Violating this
    /// can cause data races.
    ///
    /// # Returns
    ///
    /// A mutable reference to the stored value.
    #[allow(clippy::mut_from_ref)]
    unsafe fn get_mut(&self) -> &mut T {
        unsafe { &mut *self.0.get() }
    }

    /// Returns an immutable reference to the stored value.
    ///
    /// # Safety
    ///
    /// The caller must ensure that no other code is concurrently modifying
    /// the value, or that proper synchronization is in place.
    ///
    /// # Returns
    ///
    /// An immutable reference to the stored value.
    unsafe fn get(&self) -> &T {
        unsafe { &*self.0.get() }
    }
}

/// Global storage for the bump allocator used for graph allocation.
///
/// Initialized by the primary core during boot to manage memory for the
/// decoding graph structure. The allocator manages a fixed region of memory
/// and is never deallocated during firmware execution.
static GRAPH_ALLOC: GlobalCell<Option<BumpAllocator>> = GlobalCell::new(None);

/// Global reference to the loaded decoding graph.
///
/// Stored as a static reference after being leaked from a Box to extend
/// its lifetime beyond the allocation scope. The graph is shared read-only
/// by all worker cores, so a single reference is sufficient.
static GRAPH_REF: GlobalCell<Option<&'static DecodingGraph<&'static BumpAllocator>>> =
    GlobalCell::new(None);

use core::arch::global_asm;
global_asm!(include_str!("entry.S"));

/// Main entry point called from assembly boot code.
///
/// Reads the hardware thread ID (hart ID) and dispatches to either the
/// primary main function (hart 0) or worker main function (other harts).
/// This function never returns, as both primary and worker functions
/// run infinite loops.
///
/// # Safety
///
/// This function is marked as no_mangle and extern "C" to match the
/// calling convention expected by the assembly boot code. It must be
/// called exactly once per hart during system initialization.
#[unsafe(no_mangle)]
pub extern "C" fn kmain() -> ! {
    let hartid: usize;
    unsafe {
        core::arch::asm!("csrr {}, mhartid", out(reg) hartid);
    }

    if hartid == 0 {
        primary_main();
    } else {
        worker_main(hartid);
    }
}

/// Primary core main function (hart 0).
///
/// Initializes the system by loading the decoding graph, then enters a loop
/// that generates syndrome packets from benchmark data and pushes them into
/// the job queue. Periodically prints statistics about throughput and latency.
/// This function never returns, running indefinitely to sustain continuous
/// decoding workload.
fn primary_main() -> ! {
    console::init();
    console::println!("[BOOT] Core 0 Online");

    unsafe {
        *GRAPH_ALLOC.get_mut() = Some(BumpAllocator::new(0x8400_0000, 0x400000));
        let alloc_ref = GRAPH_ALLOC.get().as_ref().unwrap();

        let (graph, _) = parse_graph_dem(alloc_ref);
        let leaked_graph = alloc::boxed::Box::leak(alloc::boxed::Box::new_in(graph, alloc_ref));

        *GRAPH_REF.get_mut() = Some(leaked_graph);
    }

    SYSTEM_READY.store(true, Ordering::Release);

    // Memory-mapped address of the machine timer register.
    //
    // The machine timer (mtime) provides a 64-bit counter that increments
    // at a fixed frequency. Used for timestamping syndrome packets and
    // measuring decoding latency. The address is defined in the common
    // MMIO module to ensure consistency across firmware and host code.
    const MTIME_ADDR: usize = qcu_common::mmio::MTIME_ADDR;

    // Target interval between syndrome packet generations (machine timer ticks).
    //
    // Controls the rate at which the primary core generates and enqueues
    // syndrome packets. The value of 222 ticks corresponds to approximately
    // 10 kHz generation rate, matching typical quantum measurement frequencies.
    // This interval ensures the job queue remains fed without overwhelming
    // worker cores.
    const TARGET_INTERVAL: u64 = 222;

    let mut data_idx = 0;
    let mut last_print_time = unsafe { (MTIME_ADDR as *const u64).read_volatile() };
    let mut last_processed = 0;
    let mut next_shot_time = unsafe { (MTIME_ADDR as *const u64).read_volatile() };

    loop {
        let now = unsafe { (MTIME_ADDR as *const u64).read_volatile() };

        if now < next_shot_time {
            core::hint::spin_loop();
            continue;
        }
        next_shot_time += TARGET_INTERVAL;

        let offset = data_idx * bench_data::WORDS_PER_SHOT;
        let mut syndromes = [0u64; WORDS_PER_SHOT];

        if offset + WORDS_PER_SHOT <= bench_data::BENCH_DATA.len() {
            syndromes.copy_from_slice(&bench_data::BENCH_DATA[offset..offset + WORDS_PER_SHOT]);
        } else {
            data_idx = 0;
        }

        let packet = SyndromePacket {
            shot_id: data_idx as u64,
            timestamp: now,
            syndromes,
        };

        if JOB_QUEUE.push(packet).is_ok() {
            QUEUE_DEPTH.fetch_add(1, Ordering::Relaxed);
            data_idx = (data_idx + 1) % bench_data::TOTAL_SHOTS;
        }

        if now.wrapping_sub(last_print_time) >= 10_000_000 {
            let total = TOTAL_PROCESSED.load(Ordering::Relaxed);
            let depth = QUEUE_DEPTH.load(Ordering::Relaxed);
            let sum = LATENCY_SUM.swap(0, Ordering::Relaxed);
            let max = LATENCY_MAX.swap(0, Ordering::Relaxed);
            let min = LATENCY_MIN.swap(u64::MAX, Ordering::Relaxed);

            let delta = total.wrapping_sub(last_processed);
            let avg = if delta > 0 { sum / delta } else { 0 };

            console::println!(
                "T={:3}s | Rate: {:6}/s | Lat: {:4}/{:4}/{:4} | Q: {:4}",
                now / 10_000_000,
                delta,
                min,
                avg,
                max,
                depth
            );

            last_print_time = now;
            last_processed = total;
        }
    }
}

/// Worker core main function (hart 1+).
///
/// Waits for system initialization to complete, then enters a loop that pops
/// syndrome packets from the job queue, unpacks the syndrome bits, runs the
/// decoder, and records latency statistics. Each worker core operates independently,
/// processing jobs in parallel to maximize throughput. This function never returns.
///
/// # Arguments
///
/// * `hartid` - Hardware thread ID for this worker core
fn worker_main(hartid: usize) -> ! {
    while !SYSTEM_READY.load(Ordering::Acquire) {
        core::hint::spin_loop();
    }

    let graph = unsafe { GRAPH_REF.get().as_ref().unwrap() };

    let mut decoder = UnionFindDecoder::<MAX_NODES>::new();
    let mut syndrome_indices: StaticVec<usize, 1024> = StaticVec::new();
    let mut corrections: StaticVec<(usize, usize), 1024> = StaticVec::new();

    console::println!("[WORKER] Core {} Ready", hartid);

    // Memory-mapped address of the machine timer register.
    //
    // Used by worker cores to read the current time for latency measurement.
    // The timer value is compared against packet timestamps to compute
    // decoding latency statistics.
    const MTIME_ADDR: usize = qcu_common::mmio::MTIME_ADDR;

    loop {
        if let Some(packet) = JOB_QUEUE.pop() {
            QUEUE_DEPTH.fetch_sub(1, Ordering::Relaxed);

            syndrome_indices.clear();
            for (i, &word) in packet.syndromes.iter().enumerate() {
                let mut w = word;
                let mut bit = 0;
                while w > 0 {
                    if w & 1 == 1 {
                        let _ = syndrome_indices.push(i * 64 + bit);
                    }
                    w >>= 1;
                    bit += 1;
                }
            }

            #[cfg(not(feature = "use_fpga_mmio"))]
            {
                if decoder
                    .solve_into(graph, &syndrome_indices, &mut corrections)
                    .is_ok()
                {
                    let now = unsafe { (MTIME_ADDR as *const u64).read_volatile() };
                    let latency = now.wrapping_sub(packet.timestamp);

                    TOTAL_PROCESSED.fetch_add(1, Ordering::Relaxed);
                    LATENCY_SUM.fetch_add(latency, Ordering::Relaxed);
                    LATENCY_MAX.fetch_max(latency, Ordering::Relaxed);
                    LATENCY_MIN.fetch_min(latency, Ordering::Relaxed);
                }
            }
        } else {
            core::hint::spin_loop();
        }
    }
}

/// Parses a decoding graph from DEM (Detector Error Model) format.
///
/// Reads the embedded DEM data string and constructs a DecodingGraph by
/// parsing "error" lines that specify edges between detector nodes. The
/// format is: "error(probability) D<u> D<v>" where u and v are detector
/// node indices. Returns the graph and the maximum node ID encountered.
///
/// # Arguments
///
/// * `alloc` - Allocator for graph edge storage
///
/// # Returns
///
/// A tuple containing the constructed graph and the number of nodes (max_id + 1).
fn parse_graph_dem(alloc: &BumpAllocator) -> (DecodingGraph<&BumpAllocator>, usize) {
    let mut graph = DecodingGraph::new_in(120_000, alloc);
    let mut max_node_id = 0;

    for line in DEM_DATA.split('\n') {
        let trimmed: &str = line.trim();
        if trimmed.starts_with("error") {
            let mut parts = trimmed.split_whitespace();
            parts.next();
            let mut u = usize::MAX;
            let mut v = usize::MAX;

            for part in parts {
                if let Some(Ok(idx)) = part.strip_prefix('D').map(core::str::FromStr::from_str) {
                    if idx > max_node_id {
                        max_node_id = idx;
                    }
                    if u == usize::MAX {
                        u = idx;
                    } else if v == usize::MAX {
                        v = idx;
                    }
                }
            }
            if u != usize::MAX && v != usize::MAX {
                let _ = graph.add_edge(u, v, 1.0);
            }
        }
    }
    (graph, max_node_id + 1)
}

/// Panic handler for firmware error conditions.
///
/// Called when a panic occurs (e.g., assertion failure, out-of-bounds access).
/// Prints panic information to the console, then attempts to exit QEMU by
/// writing a magic value to the QEMU exit device. If QEMU exit fails or is
/// unavailable, enters an infinite loop to halt execution.
///
/// # Arguments
///
/// * `info` - Panic information including message and location
#[panic_handler]
fn panic(info: &core::panic::PanicInfo) -> ! {
    console::println!("PANIC: {:?}", info);
    unsafe {
        let qemu_exit = 0x100000 as *mut u32;
        qemu_exit.write_volatile(0x5555);
    }
    loop {}
}
