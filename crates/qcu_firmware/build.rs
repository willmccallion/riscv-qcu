/// Build script for qcu_firmware crate.
///
/// Copies the memory layout linker script and generates embedded benchmark
/// data from .b8 and .dem files. Converts binary measurement data into a
/// Rust array of u64 words for efficient firmware access. If benchmark data
/// files are missing, generates empty dummy data to allow compilation.
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

/// Build script entry point for firmware compilation.
///
/// Configures the linker with the memory layout script and generates embedded
/// benchmark data from .b8 and .dem files. The benchmark data is converted
/// into a Rust array of u64 words for efficient firmware access. If benchmark
/// data files are missing, generates empty dummy data to allow compilation
/// to proceed without errors.
fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    fs::copy("memory.x", out_dir.join("memory.x")).expect("failed to copy memory.x");
    println!("cargo:rustc-link-search={}", out_dir.display());
    println!("cargo:rerun-if-changed=memory.x");
    println!("cargo:rustc-link-arg=-Tmemory.x");

    let dest_path = out_dir.join("bench_data.rs");
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_dir = Path::new(&manifest_dir).join("../../output");
    let b8_path = output_dir.join("bench.b8");
    let dem_path = output_dir.join("bench.dem");

    println!("cargo:rerun-if-changed={}", b8_path.display());
    println!("cargo:rerun-if-changed={}", dem_path.display());

    // Number of 64-bit words required to store syndrome data for one shot.
    //
    // Each word can represent 64 detector bits, so this constant determines
    // the maximum number of detectors supported per quantum measurement shot.
    // The value of 160 words supports up to 10,240 detectors per shot.
    const WORDS_PER_SHOT: usize = 160;

    // Size of a syndrome packet in bytes.
    //
    // Calculated as WORDS_PER_SHOT * 8 (bytes per u64 word). Used to allocate
    // buffers for reading and processing syndrome data from the .b8 file.
    const PACKET_SIZE: usize = WORDS_PER_SHOT * 8;

    if !b8_path.exists() || !dem_path.exists() {
        println!(
            "cargo:warning=Benchmark data not found at {}. Using empty dummy data.",
            b8_path.display()
        );
        let mut f = fs::File::create(&dest_path).unwrap();
        writeln!(f, "pub const TOTAL_SHOTS: usize = 0;").unwrap();
        writeln!(f, "pub const WORDS_PER_SHOT: usize = {};", WORDS_PER_SHOT).unwrap();
        writeln!(f, "#[unsafe(link_section = \".rodata\")]").unwrap();
        writeln!(f, "pub static BENCH_DATA: [u64; 0] = [];").unwrap();
        return;
    }

    let dem_content = fs::read_to_string(&dem_path).expect("Failed to read .dem file");
    let mut max_node_id = 0;
    for line in dem_content.lines() {
        for part in line.split_whitespace() {
            if let Some(id) = part.strip_prefix('D').and_then(|s| s.parse::<usize>().ok())
                && id > max_node_id
            {
                max_node_id = id;
            }
        }
    }
    let num_detectors = max_node_id + 1;

    let raw_data = fs::read(&b8_path).expect("Failed to read .b8 file");

    let bytes_per_shot_file = num_detectors.div_ceil(8);

    let total_shots = if bytes_per_shot_file > 0 {
        raw_data.len() / bytes_per_shot_file
    } else {
        0
    };

    let mut f = fs::File::create(&dest_path).unwrap();

    writeln!(f, "// GENERATED BY build.rs").unwrap();
    writeln!(f, "pub const TOTAL_SHOTS: usize = {};", total_shots).unwrap();
    writeln!(f, "pub const WORDS_PER_SHOT: usize = {};", WORDS_PER_SHOT).unwrap();
    writeln!(f, "#[unsafe(link_section = \".rodata\")]").unwrap();
    writeln!(
        f,
        "pub static BENCH_DATA: [u64; {}] = [",
        total_shots * WORDS_PER_SHOT
    )
    .unwrap();

    for i in 0..total_shots {
        let start = i * bytes_per_shot_file;
        let end = start + bytes_per_shot_file;

        if end > raw_data.len() {
            break;
        }

        let shot_slice = &raw_data[start..end];
        let mut buffer = [0u8; PACKET_SIZE];
        let copy_len = shot_slice.len().min(PACKET_SIZE);
        buffer[0..copy_len].copy_from_slice(&shot_slice[0..copy_len]);

        write!(f, "    ").unwrap();
        for chunk in buffer.chunks(8) {
            let word = u64::from_le_bytes(chunk.try_into().unwrap());
            write!(f, "0x{:016x}, ", word).unwrap();
        }
        writeln!(f).unwrap();
    }
    writeln!(f, "];").unwrap();
}
